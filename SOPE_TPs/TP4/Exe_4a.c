// PROGRAMA p04a.c
#define _POSIX_SOURCE

#include <wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main(void)
{
    pid_t pid;
    int i, n, status;

    for (i=1; i<=3; i++) {
        pid=fork(); 

        if (pid == 0){
            printf("CHILD no. %d (PID=%d) working ... \n",i,getpid());
            sleep(i*7); // child working ...
            printf("CHILD no. %d (PID=%d) exiting ... \n",i,getpid());
            exit(0);
        }
    }

    for (i=1 ;i<=4; i++ ) {

        printf("PARENT: working hard (task no. %d) ...\n",i);
        n=20; while((n=sleep(n))!=0); // WHen SIGCHILD is sent, has no handler is installed, the signal is ignored hence sleep() is not interrupted.
        printf("PARENT: end of task no. %d\n",i);
        printf("PARENT: waiting for child no. %d ...\n",i);

        // pid=wait(&status);
        for(int j = 1; j <= 3; j++) // There are at most 3 child processes, that's why we make 3 waitpid calls :)
        {
            pid = waitpid(-1, &status, WNOHANG); // Doesn't block when no child has ended... It continues...

            if (pid != -1)
                printf("PARENT: child with PID=%d terminated with exit code %d\n",pid,WEXITSTATUS(status));
        }
        
    }
    exit(0);
}

/*

Question A ->

Em cada chamada wait é apenas libertado um processo, com exceção da última em que nenhum é libertado,
pois já não existem mais filhos (return -1 (ERROR)). Como o tempo de execução do processo pai varia bastante, por vezes
os seus processos filho ficam largos segundos em estado zombie. Só ao fim de no máximo 20 segundos é que um processo defunct pode
finalmente deixar de existir, o que termos de processamento, é mesmo muito tempo.

*/

/*

Question B ->

As a signal sent to the parent process is also sent to his child processes, as none of them handle the SIGINT, they all exit abruptly.
Hence the execution is ends.

Question C ->

CTRL + C "SIGINT signal is generated by the termianl line disciplice, and broadcast to all processes in the 
terminal's foreground process group. Which means that the signal is sent to all processes that are in the same
process group ID as the bash itself. (TPGID = Terminal process group ID). When CTRL + C is pressed in the same
terminal window, as all the processes are the same TPGID, they all terminate instantly because none of them has an
handler installed for SIGINT. In case SIGINT is sent using a different terminal window, only the parent process ends
as SIGINT can't be broadcasted to the other same terminal process group processes (because we're using different terminals).
That is done using kill -s SIGINT PPID. If we wanted to kill all processes in the same process group ID, which would
consequently close the child processes we would need to ue kill -INT -PGID.

ps ax -o pgrp -> To check PROCESS GROUP ID of each process!
ps ax -o tgpid -> To check TERMINAL PROCESS GROUP ID of each process!

*/